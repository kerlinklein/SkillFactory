import numpy as np


def score_game(game_core):
    '''Запускаем игру 1000 раз, чтобы узнать, как быстро игра угадывает число'''
    count_ls = []
    # фиксируем RANDOM SEED, чтобы ваш эксперимент был воспроизводим!
    np.random.seed(1)
    random_array = np.random.randint(1, 101, size=(1000))
    for number in random_array:
        count_ls.append(game_core(number))
    score = int(np.mean(count_ls))
    print(f"Ваш алгоритм угадывает число в среднем за {score} попыток")
    return(score)


def game_core_my(number):
    '''Для увеличения скорости сходимости будем идти к искомому числу с шагом половины разницы между этими числами'''
    count = 1
    predict = 50  # "наше" число - берем среднее число между 1 и 100

    while number != predict:
        count += 1
        if number > predict:                     # Проверка, если наше число больше, чем искомое,
            predict += int((number - predict)/2) # то увеличиваем наше число на среднее значение между искомым
                                                 # и нашим числом.
            if number - predict == 1:            # Когда мы подошли уже на единицу к искомому числу, то чтобы избежать
                                                 # зацикливания (int от 1/2 всегда 0),
                if count >= 3:                   # при условии проверки на "длительность" поиска (если изначально искомое
                                                 # число отличается от нашего меньше, чем на 2) -
                    return(count+1)              # выходим из цикла, добавляя еще одну попытку.
                else:
                    return(count)                # Если загаданное число отличается от нашего на единицу -
                                                 # мы всегда угадываем его за 2 попытки.
        elif number < predict:                   # Проверка, если наше число больше, чем искомое,
            predict -= int((predict - number)/2) # то уменьшаем наше число на среднее значение между искомым
                                                 # и нашим числом.
            if predict - number == 1:            # Когда мы подошли уже на единицу к искомому числу, то чтобы избежать
                                                 # зацикливания (int от 1/2 всегда 0),
                if count >= 3:                   # при условии проверки на "длительность" поиска (если изначально искомое
                                                 # число отличается от нашего меньше, чем на 2) -
                    return(count+1)              # выходим из цикла, добавляя еще одну попытку.
                    
                else:                            # если загаданное число отличается от нашего на единицу -
                    return(count)                # мы всегда угадываем его за 2 попытки
                    
    return(count)                                # выход из цикла, если угадали число с первого раза (number = 50)


score_game(game_core_my)





